\newcommand{\function}[4]{
  \textbf{#1} (\emph{#2}): #3 \newline
  \emph{\color{teal} #4}
}


\subsection{Design decisions}
\emph{Our interpretation of the task.} There are doctors and patients. The doctors are able to mint Vaccination Slot tokens. The doctors are able to burn \emph{(invalidate)} a token. The most important properties of a single token are: Type \emph{(of the vaccine)}, Date \emph{(when the token should be burned)}, Burned \emph{(is it used up)}, Previous \emph{(previous vaccine type the patient got)}.

A patient can hold only one non-burned token and unlimited number of burned. A patient cannot trade a burned token.


\subsection{Data model}
TokenId is generated as a Universal Unique Identifier. Type is actually an \emph{enum} and it can be any of the following:
\begin{itemize}
  \item Alpha
  \item Bravo
  \item Charlie
  \item Delta
  \item Echo
\end{itemize}

\begin{center}
  \begin{table}[!ht]
    \centering
    \begin{tabular}{|c | c | c | c |}
      \hline
      \multicolumn{4}{|c|}{Token}                                              \\
      \hline
      name     & type      & comment                   & implemented interface \\
      \hline
      TokenId  & string    & generated id of the token & erc721                \\
      Type     & string    & vaccine type (enum)       & vaccinationSlot       \\
      Date     & time.Time & vaccination date          & vaccinationSlot       \\
      Previous & string    & vaccine type (enum)       & vaccinationSlot       \\
      Owner    & string    & owner of the token        & erc721                \\
      Burned   & boolean   & is it used up             & erc721 optional       \\
      Approved & string    &                           & erc721                \\
      \hline
    \end{tabular}
    \caption{Vaccination Slot token's data model.}
  \end{table}
\end{center}


\begin{center}
  \begin{table}[!ht]
    \centering
    \begin{tabular}{| c | c |}
      \hline
      \multicolumn{2}{|c|}{Approval} \\
      \hline
      name     & type                \\
      \hline
      Owner    & string              \\
      Operator & string              \\
      Approved & bool                \\
      \hline
    \end{tabular}
    \caption{Approval object's data model.}
  \end{table}
\end{center}

\begin{center}
  \begin{table}[!ht]
    \centering
    \begin{tabular}{| c | c |}
      \hline
      \multicolumn{2}{|c|}{Transfer} \\
      \hline
      name    & type                 \\
      \hline
      From    & string               \\
      To      & string               \\
      TokenId & string               \\
      \hline
    \end{tabular}
    \caption{Transfer object's data model.}
  \end{table}
\end{center}

\newpage
\subsection{API}
Inherited from \href{https://eips.ethereum.org/EIPS/eip-721}{ERC-721 specification}, function names may differ. For more specific developer documentation \href{run:spec.pdf}{see generated \emph{godoc}.}
\subsubsection{Callable functions}
\begin{itemize}
  \item \function{BalanceOf}{owner string}{int}{Returns number of tokens in owner's wallet.}
  \item \function{OwnerOf}{tokenId string}{string}{Returns owner of token.}
  \item \function{TransferFrom}{from string, to string, tokenId string}{bool}{Transfering a token from wallet A to wallet B (if successful). }
  \item \function{Approve}{operator string, tokenId string}{bool}{ Change or reaffirm the approved address for an NFT. }
  \item \function{SetApprovalForAll}{operator string, approved bool}{bool}{ Enable or disable approval for a third party ("operator") to manage
  ///  all of `msg.sender`'s assets.  }
  \item \function{GetApproved}{tokenId string}{string}{ Get the approved address for a single NFT }
  \item \function{IsApprovedForAll}{owner string, operator string}{bool}{ Query if an address is an authorized operator for another address.  }
  \item \function{ClientAccountId}{}{string}{ Returns clientAccountId string }
  \item \function{GetSlots}{owner string}{VaccinationSlot[ ]}{ Queries vaccination slots belonging to owner.
  }
  \item \function{IssueSlot}{vaccine string, date string, patient string}{string}{ Create's a slot (if client is authorized) and transfers to specific patient (wallet). }
\end{itemize}
\subsubsection{Non-callable functions}
\begin{itemize}
  \item \function{readVaccinationSlot}{tokenId string}{VaccinationSlot}{Retrives a token by tokenId.}
  \item \function{vaccinationSlotExists}{tokenId string}{bool}{Returns a boolean whether the token exists or not.}
\end{itemize}


\subsection{Implemention details}
There are doctors and patients. The doctors are able to mint and burn Vaccination Slot tokens. The most important properties of a single token are: Type \emph{(of the vaccine)}, Date \emph{(when the token should be burned)}, Burned \emph{(is it used up)}, Previous \emph{(previous vaccine type the patient got)}.
Type can be any of the following: \emph{Alpha}, \emph{Bravo}, \emph{Charlie}, \emph{Delta}, \emph{Echo}. Date represents a single day. For a single day, all permutation can be minted by doctors, so two tokens can exist with the same type and date but different tokenIds and held by different patients.

A patient can hold only one non-burned token and unlimited number of burned. A patient cannot trade a burned token.
A patient can trade a valid token disregarding the previous burned token. \emph{If a patient's first vaccine was an Alpha one and got another Alpha token from the doctors, it is allowed to trade it for a Bravo token.}


\newpage
\subsection{Test cases}
Doctor wallets are created when the network starts running.

\subsubsection{Successful token minting}
\paragraph*{Steps}
\begin{enumerate}
  \item create network
  \item create wallet A
  \item doctor mints token X and transfers to A
\end{enumerate}
\textbf{Expected outcome:} Wallet A has valid token X

\subsubsection{Unauthorized token minting}
\paragraph*{Steps}
\begin{enumerate}
  \item create network
  \item create wallet A
  \item create wallet B
  \item wallet A mints token X and transfers to B
\end{enumerate}
\textbf{Expected outcome:} Minting unsuccessful, wallet A isn't authorized to mint tokens.

\subsubsection{Successful trading}
\paragraph*{Steps}
\begin{enumerate}
  \item create network
  \item create wallet A
  \item create wallet B
  \item doctor mints token X and transfers to A
  \item A transfers token X to wallet B
\end{enumerate}
\textbf{Expected outcome:} Trading successful, wallet B has token X.

\subsubsection{Trading a burned token}
\paragraph*{Steps}
\begin{enumerate}
  \item create network
  \item create wallet A
  \item create wallet B
  \item doctor mints token X and transfers to A
  \item wallet A uses token X, token get's burned by doctor
  \item A transfers token X to wallet B
\end{enumerate}
\textbf{Expected outcome:} Trading unsuccessful, wallet A cannot trade a burned token.

\subsubsection{Trading a token with invalid date}
\paragraph*{Steps}
\begin{enumerate}
  \item create network
  \item create wallet A
  \item create wallet B
  \item doctor mints token X and transfers to A
  \item A transfers token X to wallet B
\end{enumerate}
\textbf{Expected outcome:} Trading unsuccessful, wallet A cannot trade a token with invalid date.

\subsubsection{Trading a nonexistent token}
\paragraph*{Steps}
\begin{enumerate}
  \item create network
  \item create wallet A
  \item create wallet B
  \item A transfers token X to wallet B
\end{enumerate}
\textbf{Expected outcome:} Trading unsuccessful, wallet A cannot trade a nonexistent token.
